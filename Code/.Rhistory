library(tcltk)
library(ECOTOXr)
GB <- read.xlsx("C:/Users/owner/OneDrive - huji.ac.il/PhD/reports/GreenBasine/CW_nabulus_raw.xlsx")
gb_p <- GB %>%
select(1, 4, 21:ncol(.)) %>%
mutate(across(3:ncol(.), ~as.numeric(.) %>% replace_na(0))) %>%
filter(rowSums(across(3:ncol(.))) > 0) %>%
pivot_longer(cols = 3:length(.), names_to = "PREFERRED_NAME", values_to = "Concentration") %>%
pivot_wider(names_from = c(1,2), values_from = Concentration)
NUKA <- read.fst("C:/Users/owner/Desktop/TaxoTox/Data/NUKA.fst") %>%
rename("CASRN" = CAS)
# DSSTox - database of over milion pollutants, their names and IUPAC names
DSSTox <- read.fst("C:/Users/owner/Desktop/DSSTox.fst")
GB <- read.xlsx("C:/Users/owner/OneDrive - huji.ac.il/PhD/reports/GreenBasine/CW_nabulus_raw.xlsx")
gb_p <- GB %>%
select(1, 4, 21:ncol(.)) %>%
mutate(across(3:ncol(.), ~as.numeric(.) %>% replace_na(0))) %>%
filter(rowSums(across(3:ncol(.))) > 0) %>%
pivot_longer(cols = 3:length(.), names_to = "PREFERRED_NAME", values_to = "Concentration") %>%
pivot_wider(names_from = c(1,2), values_from = Concentration)
NUKA <- read.fst("C:/Users/owner/Desktop/TaxoTox/Data/NUKA.fst") %>%
rename("CASRN" = CAS)
# DSSTox - database of over milion pollutants, their names and IUPAC names
DSSTox <- read.fst("C:/Users/owner/Desktop/DSSTox.fst")
Internal_data <- gb_p # The user's data
# Convert to data.table for more efficient operations
setDT(NUKA)
setDT(DSSTox)
setDT(Internal_data)
p_vector <- Internal_data[[1]] # Create a vector of compounds from the user's data for CAS search
## First search - NUKA (exact matches)
internal_list <- NUKA[NUKA$PREFERRED_NAME %in% p_vector, ]
p_vector_found <- internal_list$PREFERRED_NAME # Creating a vector of all pollutants that were found
unfound <- p_vector[!p_vector %in% p_vector_found] # Saving the pollutants that weren't found in NUKA for further search in DSSTox
# Create a data.table for unfounded pollutants for easier manipulation
unfound_dt <- data.table(PREFERRED_NAME = unfound)
# Second search - DSSTox (fuzzy)
# Interactive fuzzy matching function
fuzzy_match_interactive <- function(source_names, target_dt, match_col, threshold = 0.05, confirm_threshold = 0.01) {
result <- data.table(
source_name = source_names,
matched_name = NA_character_,
distance = NA_real_,
confirmed = FALSE
)
for (i in 1:length(source_names)) {
name <- source_names[i]
if (is.na(name)) {
next
}
valid_targets <- target_dt[[match_col]][!is.na(target_dt[[match_col]])] # Calculate distances to all target names (excluding NA targets)
if (length(valid_targets) == 0) { # Handle case where there are no valid targets
next
}
distances <- stringdist(name, valid_targets, method = "jw")
if (length(distances) > 0 && !all(is.na(distances))) { # Find the best match if any valid distances exist
min_dist <- min(distances, na.rm = TRUE)
best_idx <- which.min(distances)
best_match <- valid_targets[best_idx]
match_quality <- round((1 - min_dist) * 100, 1)
if (!is.na(min_dist) && min_dist <= threshold) {  # Get CASRN number for the matched compound
casrn_number <- target_dt[get(match_col) == best_match, CASRN]
casrn_display <- if(length(casrn_number) > 0 && !is.na(casrn_number[1])) casrn_number[1] else "Not available"
if (match_quality == 100) { # Auto-accept perfect matches
confirmed <- TRUE
} else if (match_quality >= threshold) { # Show message box for high confidence matches (95% and above, but not 100%)
message_text <- paste0(
"Match found:\n\n",
"Source compound:  ", name, "\n",
"Matched compound: ", best_match, "\n",
"CASRN number: ", casrn_display, "\n",
"Match confidence: ", match_quality, "%\n\n",
"Do you want to accept this match?"
)
answer <- tcltk::tkmessageBox( # Display message box with consistent format
title = paste0("Compound Match (", match_quality, "% confidence)"),
message = message_text,
icon = "question",
type = "yesno"
)
confirmed <- as.character(answer) == "yes"
} else {
confirmed <- FALSE
}
if (confirmed) {
result[i, `:=`(
matched_name = best_match,
distance = min_dist,
confirmed = TRUE
)]
}
}
}
}
return(result)
}
# Run the interactive matching
matches <- fuzzy_match_interactive(
unfound,
DSSTox,
"PREFERRED_NAME",
threshold = 0.1,      # Maximum allowed distance - needs to be defind by the user?
confirm_threshold = 0  # Auto-accept
)
# Create final result data.table with CASRN numbers
# First, get the CASRN numbers for exact matches from NUKA
exact_matches <- NUKA[PREFERRED_NAME %in% p_vector_found, .(PREFERRED_NAME, CASRN)]
# Then get CASRN numbers for fuzzy matches from DSSTox
fuzzy_confirmed <- matches[confirmed == TRUE]
fuzzy_matches <- DSSTox[DSSTox$PREFERRED_NAME %in% fuzzy_confirmed$matched_name,
.(PREFERRED_NAME, CASRN)]
# Map the original names to the matched DSSTox names to get CASRN numbers
fuzzy_results <- merge(
fuzzy_confirmed[, .(source_name, matched_name)],
fuzzy_matches,
by.x = "matched_name",
by.y = "PREFERRED_NAME",
all.x = TRUE
)
# Rename columns for consistency
setnames(fuzzy_results, "source_name", "PREFERRED_NAME")
# Combine exact and fuzzy matches
final_results <- rbindlist(
list(
exact_matches,
fuzzy_results[, .(PREFERRED_NAME, CASRN)]
),
use.names = TRUE,
fill = TRUE
)
#search CARSN result:
percentage_found <- round((nrow(final_results) * 100 / length(p_vector)), 1)
#information about first stage- how many found and not found in exact search from NUKA
print(paste("Number of compounds found in NUKA:", length(p_vector_found), "out of", length(p_vector)))
# Count confirmed matches
match_count <- sum(matches$confirmed, na.rm = TRUE)
print(paste("Number of confirmed fuzzy matches (exact match from DSSTox):", match_count))
# Count unexact matches (matches accepted through message box, excluding 100% matches)
unexact_matches <- sum(matches$confirmed == TRUE & matches$distance > 0, na.rm = TRUE)
print(paste("Number of unexact matches accepted by user:", unexact_matches))
print(paste("Total pollutants with CASRN numbers:", nrow(final_results), "out of", length(p_vector), "(",percentage_found,"%)"))
final_results
View(final_results)
# Step 3 - Auto fill of the rest of the pollutnat's CASRN
str(final_results)
# Combine exact and fuzzy matches
final__search_results <- rbindlist(
list(
exact_matches,
fuzzy_results[, .(PREFERRED_NAME, CASRN)]
),
use.names = TRUE,
fill = TRUE
)
#search CARSN result:
percentage_found <- round((nrow(final__search_results) * 100 / length(p_vector)), 1)
#information about first stage- how many found and not found in exact search from NUKA
print(paste("Number of compounds found in NUKA:", length(p_vector_found), "out of", length(p_vector)))
# Count confirmed matches
match_count <- sum(matches$confirmed, na.rm = TRUE)
print(paste("Number of confirmed fuzzy matches (exact match from DSSTox):", match_count))
# Count unexact matches (matches accepted through message box, excluding 100% matches)
unexact_matches <- sum(matches$confirmed == TRUE & matches$distance > 0, na.rm = TRUE)
print(paste("Number of unexact matches accepted by user:", unexact_matches))
print(paste("Total pollutants with CASRN numbers:", nrow(final__search_results), "out of", length(p_vector), "(",percentage_found,"%)"))
all_p_df <- data.frame(
PREFERRED_NAME = p_vector,
CASRN = NA,
stringsAsFactors = FALSE
)
# Combine and remove duplicates, keeping original CASRN values when they exist
manual_fill_df <- bind_rows(final__search_results, all_p_df) %>%
group_by(PREFERRED_NAME) %>%
summarise(CASRN = first(CASRN[!is.na(CASRN)]), .groups = 'drop') %>%
mutate(CASRN = ifelse(is.na(CASRN), "", CASRN))
manual_fill_df
View(manual_fill_df)
View(final__search_results)
View(all_p_df)
# Combine and remove duplicates, keeping original CASRN values when they exist
manual_fill_df <- bind_rows(final__search_results, all_p_df) %>%
group_by(PREFERRED_NAME) %>%
summarise(CASRN = first(CASRN[!is.na(CASRN)]), .groups = 'drop') %>%
mutate(CASRN = ifelse(is.na(CASRN), "", CASRN))
View(manual_fill_df)
manual_fill_df <- bind_rows(final__search_results, all_p_df)
View(manual_fill_df)
# Combine and remove duplicates, keeping original CASRN values when they exist
manual_fill_df <- bind_rows(final__search_results, all_p_df) %>%
group_by(PREFERRED_NAME) %>%
summarise(CASRN = ifelse(any(!is.na(CASRN) & CASRN != ""),
first(CASRN[!is.na(CASRN) & CASRN != ""]),
""),
.groups = 'drop')
View(manual_fill_df)
write.csv(manual_fill_df, "manual_fill.csv")
#write.csv(manual_fill_df, "manual_fill.csv") #fill
all_cas <- read_csv("TaxoTox/Data/manual_fill.csv")
#write.csv(manual_fill_df, "manual_fill.csv") #fill
all_cas <- read_csv("../Data/manual_fill.csv")
View(all_cas)
View(all_cas)
p_final <- as.vector(all_cas$CASRN) %>%  #save as vector- without "-" (as appear in ecotox)
gsub("-", "", .)
# Convert the vector to a comma-separated string for the SQL IN clause
cas_list <- paste0("'", p_final, "'", collapse = ", ")
mysearch <- paste0("SELECT
-- Select the relevant endpoint concentration, unit and measurment columns
results.conc1_mean AS Endpoint_Concentration,
results.conc1_unit AS Endpoint_Unit,
results.endpoint AS Endpoint,
results.measurement AS Measurement,
results.effect AS Effect,
tests.test_type AS TestType,
-- Select details about the chemical
chemicals.chemical_name AS ChemicalName,
chemicals.cas_number AS CAS_Number,
-- Select details about the organism
species.common_name AS OrganismCommonName,
species.latin_name AS OrganismLatinName,
species.phylum_division AS OrganismPhylum,
species.ecotox_group AS SpeciesGroup,
-- Select details about the test
tests.test_id AS TestID,
results.result_id AS ResultID
FROM
results -- Start with the results table where ED50 data is found
JOIN
tests ON results.test_id = tests.test_id -- Join to get test details, chemical CAS, and species number
JOIN
chemicals ON tests.test_cas = chemicals.cas_number -- Join to get chemical name from CAS number
JOIN
species ON tests.species_number = species.species_number -- Join to get species phylum/group
WHERE
chemicals.cas_number IN (", cas_list, ") -- Filter for all CAS numbers in p_final vector
AND species.ecotox_group LIKE '%Crustacea%' -- Filter for crustacea
ORDER BY
results.conc1_mean;) -- Order results for easier review")
output <- dbGetQuery(conn, mysearch) %>%
group_by(Endpoint, Effect, Measurement, TestID) %>%
summarise(n = n(), .groups = "drop")
#R TO SQL
conn <- dbConnect(RSQLite::SQLite(), "C:/Users/owner/AppData/Local/ECOTOXr/ECOTOXr/Cache/ecotox_ascii_03_13_2025.sqlite")
output <- dbGetQuery(conn, mysearch) %>%
group_by(Endpoint, Effect, Measurement, TestID) %>%
summarise(n = n(), .groups = "drop")
View(NUKA)
View(output)
unique(output$Endpoint)
output <- dbGetQuery(conn, mysearch) %>%
group_by(Endpoint, Effect, Measurement) %>%
summarise(n = n(), .groups = "drop")
View(output)
output <- dbGetQuery(conn, mysearch)
mysearch <- paste0("SELECT
-- Select the relevant endpoint concentration, unit and measurment columns
results.conc1_mean AS Endpoint_Concentration,
results.conc1_unit AS Endpoint_Unit,
results.endpoint AS Endpoint,
results.measurement AS Measurement,
results.effect AS Effect,
tests.test_type AS TestType,
-- Select details about the chemical
chemicals.chemical_name AS ChemicalName,
chemicals.cas_number AS CAS_Number,
-- Select details about the organism
species.common_name AS OrganismCommonName,
species.latin_name AS OrganismLatinName,
species.phylum_division AS OrganismPhylum,
species.ecotox_group AS SpeciesGroup,
-- Select details about the test
tests.test_id AS TestID,
results.result_id AS ResultID
FROM
results. -- Start with the results table where ED50 data is found
JOIN
tests ON results.test_id = tests.test_id -- Join to get test details, chemical CAS, and species number
JOIN
chemicals ON tests.test_cas = chemicals.cas_number -- Join to get chemical name from CAS number
JOIN
species ON tests.species_number = species.species_number -- Join to get species phylum/group
WHERE
chemicals.cas_number IN (", cas_list, ") -- Filter for all CAS numbers in p_final vector
AND species.ecotox_group LIKE '%Crustacea%' -- Filter for crustacea,
results.endpoint REGEXP 'EC50|LC50'
ORDER BY
results.conc1_mean; -- Order results for easier review)")
output <- dbGetQuery(conn, mysearch)
mysearch <- paste0("SELECT
-- Select the relevant endpoint concentration, unit and measurment columns
results.conc1_mean AS Endpoint_Concentration,
results.conc1_unit AS Endpoint_Unit,
results.endpoint AS Endpoint,
results.measurement AS Measurement,
results.effect AS Effect,
tests.test_type AS TestType,
-- Select details about the chemical
chemicals.chemical_name AS ChemicalName,
chemicals.cas_number AS CAS_Number,
-- Select details about the organism
species.common_name AS OrganismCommonName,
species.latin_name AS OrganismLatinName,
species.phylum_division AS OrganismPhylum,
species.ecotox_group AS SpeciesGroup,
-- Select details about the test
tests.test_id AS TestID,
results.result_id AS ResultID
FROM
results -- Start with the results table where ED50 data is found
JOIN
tests ON results.test_id = tests.test_id -- Join to get test details, chemical CAS, and species number
JOIN
chemicals ON tests.test_cas = chemicals.cas_number -- Join to get chemical name from CAS number
JOIN
species ON tests.species_number = species.species_number -- Join to get species phylum/group
WHERE
chemicals.cas_number IN (", cas_list, ") -- Filter for all CAS numbers in p_final vector
AND species.ecotox_group LIKE '%Crustacea%' -- Filter for crustacea
AND results.endpoint REGEXP 'EC50|LC50'
ORDER BY
results.conc1_mean; -- Order results for easier review")
output <- dbGetQuery(conn, mysearch)
mysearch <- paste0("SELECT
-- Select the relevant endpoint concentration, unit and measurment columns
results.conc1_mean AS Endpoint_Concentration,
results.conc1_unit AS Endpoint_Unit,
results.endpoint AS Endpoint,
results.measurement AS Measurement,
results.effect AS Effect,
tests.test_type AS TestType,
-- Select details about the chemical
chemicals.chemical_name AS ChemicalName,
chemicals.cas_number AS CAS_Number,
-- Select details about the organism
species.common_name AS OrganismCommonName,
species.latin_name AS OrganismLatinName,
species.phylum_division AS OrganismPhylum,
species.ecotox_group AS SpeciesGroup,
-- Select details about the test
tests.test_id AS TestID,
results.result_id AS ResultID
FROM
results -- Start with the results table where ED50 data is found
JOIN
tests ON results.test_id = tests.test_id -- Join to get test details, chemical CAS, and species number
JOIN
chemicals ON tests.test_cas = chemicals.cas_number -- Join to get chemical name from CAS number
JOIN
species ON tests.species_number = species.species_number -- Join to get species phylum/group
WHERE
chemicals.cas_number IN (", cas_list, ")
AND species.ecotox_group LIKE '%Crustacea%'
AND (results.endpoint LIKE '%EC50%' OR results.endpoint LIKE '%LC50%')
ORDER BY
results.conc1_mean; -- Order results for easier review")
output <- dbGetQuery(conn, mysearch)
View(output)
unique(output$ChemicalName)
mysearch <- paste0("SELECT
-- Select the relevant endpoint concentration, unit and measurment columns
results.conc1_mean AS Endpoint_Concentration,
results.conc1_unit AS Endpoint_Unit,
results.endpoint AS Endpoint,
results.measurement AS Measurement,
results.effect AS Effect,
tests.test_type AS TestType,
-- Select details about the chemical
chemicals.chemical_name AS ChemicalName,
chemicals.cas_number AS CAS_Number,
-- Select details about the organism
species.common_name AS OrganismCommonName,
species.latin_name AS OrganismLatinName,
species.phylum_division AS OrganismPhylum,
species.ecotox_group AS SpeciesGroup,
-- Select details about the test
tests.test_id AS TestID,
results.result_id AS ResultID
FROM
results -- Start with the results table where ED50 data is found
JOIN
tests ON results.test_id = tests.test_id -- Join to get test details, chemical CAS, and species number
JOIN
chemicals ON tests.test_cas = chemicals.cas_number -- Join to get chemical name from CAS number
JOIN
species ON tests.species_number = species.species_number -- Join to get species phylum/group
WHERE
chemicals.cas_number IN (", cas_list, ")
AND species.ecotox_group LIKE '%Crustacea%'
ORDER BY
results.conc1_mean -- Order results for easier review")
output <- dbGetQuery(conn, mysearch)
unique(output$ChemicalName)
mysearch <- paste0("SELECT
-- Select the relevant endpoint concentration, unit and measurment columns
results.conc1_mean AS Endpoint_Concentration,
results.conc1_unit AS Endpoint_Unit,
results.endpoint AS Endpoint,
results.measurement AS Measurement,
results.effect AS Effect,
tests.test_type AS TestType,
-- Select details about the chemical
chemicals.chemical_name AS ChemicalName,
chemicals.cas_number AS CAS_Number,
-- Select details about the organism
species.common_name AS OrganismCommonName,
species.latin_name AS OrganismLatinName,
species.phylum_division AS OrganismPhylum,
species.ecotox_group AS SpeciesGroup,
-- Select details about the test
tests.test_id AS TestID,
results.result_id AS ResultID
FROM
results -- Start with the results table where ED50 data is found
JOIN
tests ON results.test_id = tests.test_id -- Join to get test details, chemical CAS, and species number
JOIN
chemicals ON tests.test_cas = chemicals.cas_number -- Join to get chemical name from CAS number
JOIN
species ON tests.species_number = species.species_number -- Join to get species phylum/group
WHERE
chemicals.cas_number IN (", cas_list, ")
AND species.ecotox_group LIKE '%Crustacea%'
AND (results.endpoint LIKE '%EC50%' OR results.endpoint LIKE '%LC50%')
ORDER BY
results.conc1_mean -- Order results for easier review")
output <- dbGetQuery(conn, mysearch)
View(output)
output <- output %>%
group_by(Endpoint, Effect, Measurement) %>%
summarise(n = n(), .groups = "drop")
View(output)
mysearch <- paste0("SELECT
-- Select the relevant endpoint concentration, unit and measurment columns
results.conc1_mean AS Endpoint_Concentration,
results.conc1_unit AS Endpoint_Unit,
results.endpoint AS Endpoint,
results.measurement AS Measurement,
results.effect AS Effect,
tests.test_type AS TestType,
-- Select details about the chemical
chemicals.chemical_name AS ChemicalName,
chemicals.cas_number AS CAS_Number,
-- Select details about the organism
species.common_name AS OrganismCommonName,
species.latin_name AS OrganismLatinName,
species.phylum_division AS OrganismPhylum,
species.ecotox_group AS SpeciesGroup,
-- Select details about the test
tests.test_id AS TestID,
results.result_id AS ResultID
FROM
results -- Start with the results table where ED50 data is found
JOIN
tests ON results.test_id = tests.test_id -- Join to get test details, chemical CAS, and species number
JOIN
chemicals ON tests.test_cas = chemicals.cas_number -- Join to get chemical name from CAS number
JOIN
species ON tests.species_number = species.species_number -- Join to get species phylum/group
WHERE
chemicals.cas_number IN (", cas_list, ")
AND species.ecotox_group LIKE '%Crustacea%'
AND (results.endpoint LIKE '%EC50%' OR results.endpoint LIKE '%LC50%')
AND (results.measurement LIKE '%IMBL%' OR '%MORT%' OR '%SURV%')
AND (results.effect LIKE '%ITX%' OR '%MOR%')
ORDER BY
results.conc1_mean -- Order results for easier review")
output <- dbGetQuery(conn, mysearch)
unique(output$ChemicalName)
###  Filtering the unit that are used in test of aqueous organisems
mysearch <- paste0("SELECT
results.conc1_unit AS Endpoint_Unit,
FEOM
results
WHERE
species.ecotox_group LIKE '%Crustacea%' OR '%Algea%' OR '%Fish%'")
conc_unit <- dbGetQuery(conn, mysearch)
###  Filtering the unit that are used in test of aqueous organisems
mysearch <- paste0("SELECT
results.conc1_unit AS Endpoint_Unit
FEOM
results
WHERE
species.ecotox_group LIKE '%Crustacea%' OR '%Algea%' OR '%Fish%'")
conc_unit <- dbGetQuery(conn, mysearch)
###  Filtering the unit that are used in test of aqueous organisems
mysearch <- paste0("SELECT
results.conc1_unit AS Endpoint_Unit
FROM
results
WHERE
species.ecotox_group LIKE '%Crustacea%' OR '%Algea%' OR '%Fish%'")
conc_unit <- dbGetQuery(conn, mysearch)
###  Filtering the unit that are used in test of aqueous organisms
mysearch <- paste0("SELECT
results.conc1_unit AS Endpoint_Unit
FROM
results
JOIN
tests ON results.test_id = tests.test_id
JOIN
species ON tests.species_number = species.species_number
WHERE
species.ecotox_group LIKE '%Crustacea%'
OR species.ecotox_group LIKE '%Algae%'
OR species.ecotox_group LIKE '%Fish%'")
conc_unit <- dbGetQuery(conn, mysearch)
View(conc_unit)
unique(conc_unit)
conc_unit <- conc_unit %>%
group_by(Endpoint_Unit) %>%
summarise(n = n(), .groups = "drop")
View(conc_unit)
